#!/usr/bin/env python3

import argparse
import hashlib
import sys
import random
import mmap
import os
import subprocess
import pathlib

parser = argparse.ArgumentParser()
group = parser.add_mutually_exclusive_group()
group.add_argument("-g", "--grow-test", action="store_true")
group.add_argument("-G", "--quick-grow-test", action="store_true")
parser.add_argument("-V", "--verify", action="store_true")
args = parser.parse_args()

if args.verify:
    subprocess.check_call(["modprobe", "brd"])
    sys_blk = pathlib.Path("/sys/block")
    for i in range(8):
        dev = f"ram{i}"
        sectors = int((sys_blk / dev / "size").read_text())
        count = (sectors << 9) >> 20
        subprocess.check_call(["dd", "if=/dev/zero", f"of=/dev/{dev}",
                               "bs=1M", f"count={count}", "oflag=direct"])

subprocess.check_call("ASSUME_CLEAN=n ./setup",
                      shell=True)

kmsg = open("/dev/kmsg", "w")
fd = os.open("/dev/md0", os.O_RDWR|os.O_DIRECT)
f = os.fdopen(fd, "rb+", 0)

if args.verify:
    verify_fd = os.open("/dev/ram7", os.O_RDWR|os.O_DIRECT)

def split_blocks(d, blksz=4096):
    return [d[i:i+blksz] for i in range(0, len(d), blksz)]

def write_test(offset_sector, bb, sz=1 << 20):
    offset = offset_sector << 9
    kmsg.write(f"TEST {offset:#x} {offset_sector} {sz >> 9} {repr(bb)}\n")
    kmsg.flush()

    os.lseek(fd, offset, os.SEEK_SET)
    m1 = mmap.mmap(-1, sz)
    m1.write(bb * sz)
    os.write(fd, m1)

    if args.verify:
        os.lseek(verify_fd, offset, os.SEEK_SET)
        os.write(verify_fd, m1)

    m2 = mmap.mmap(-1, sz)
    os.lseek(fd, offset, os.SEEK_SET)
    f.readinto(m2)

    m1.seek(0)
    m2.seek(0)
    a = m1.read()
    b = m2.read()
    print(f"Wrote {len(a)} {repr(bb)}s and read back {len(b)} at {offset:#x} {offset_sector}")
    if a == b:
        return

    coupled_idx = enumerate(zip(a, b))
    res = next(idx for idx, (x, y) in coupled_idx if x != y)

    pathlib.Path("failed.dat").write_bytes(b)
    sys.exit(f"FAILED Readback at sector {offset + res:#x}")

def run_random(cnt, st=0):
    for i in range(1, cnt):
        sector = random.randrange(0, 10000)
        sz = random.randrange(512, 1 << 20, 512)
        write_test(sector, bytes([(st + i) & 0xFF]), sz)
    print()

def grow(cnt, dev):
    subprocess.call(["mdadm", "--wait", "/dev/md0"])
    subprocess.check_call(["mdadm", "--add", "/dev/md0", "--quiet", dev])
    subprocess.check_call(["mdadm", "--grow", "--raid-devices", str(cnt),
                           "/dev/md0"])
    print(f"Array grew to {cnt} devices")
    kmsg.write(f"Array grew to {cnt} devices")
    kmsg.flush()

def verify():
    try:
        print("Verifying")
        subprocess.check_call(["cmp", "-b", "-n", "10M",
                               "/dev/md0", "/dev/ram7"])
    except subprocess.SubprocessError:
        sys.exit(1)

def basic_tests():
    write_test(0, b"X")
    write_test(1544, b"Y")
    write_test(1552, b"Z")
    write_test(1560, b"A")
    write_test(1736, b"B")
    write_test(1688, b"B")
    write_test(1848, b"C")
    write_test(1520, b"D")
    print()

def grow_tests(cnt, quick=False):
    if os.getenv("LEVEL", "5") != "6":
        grow(4, "/dev/ram3")
        run_random(cnt, 0x30)

    if quick:
        return

    grow(5, "/dev/ram4")
    run_random(cnt)
    grow(6, "/dev/ram5")
    run_random(cnt)


if __name__ == "__main__":
    basic_tests()

    cnt = 400
    if args.quick_grow_test:
        cnt = 5

    run_random(cnt)

    if args.grow_test:
        grow_tests(cnt)
    elif args.quick_grow_test:
        grow_tests(cnt, True)

    if args.verify:
        verify()
