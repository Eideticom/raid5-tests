#!/usr/bin/env python3

import argparse
import hashlib
import sys
import random
import mmap
import os
import subprocess
import pathlib

class TestRunner:
    def zero_all_ram_disks(self):
        subprocess.check_call(["modprobe", "brd"])
        sys_blk = pathlib.Path("/sys/block")
        for i in range(8):
            dev = f"ram{i}"
            sectors = int((sys_blk / dev / "size").read_text())
            count = (sectors << 9) >> 20
            subprocess.check_call(["dd", "if=/dev/zero", f"of=/dev/{dev}",
                                   "bs=1M", f"count={count}", "oflag=direct"])

    def __init__(self, verify=False):
        self.verify_fd = None
        if verify:
            self.zero_all_ram_disks()
            self.verify_fd = os.open("/dev/ram7", os.O_RDWR|os.O_DIRECT)

        subprocess.check_call("ASSUME_CLEAN=n ./setup",
                              shell=True)

        md = "md0"
        self.sysfs = pathlib.Path("/sys/block") / md / "md"
        self.md_dev = f"/dev/{md}"
        self.kmsg = open("/dev/kmsg", "w")
        self.fd = os.open(self.md_dev, os.O_RDWR|os.O_DIRECT)
        self.f = os.fdopen(self.fd, "rb+", 0)

    def get_level(self):
        return (self.sysfs / "level").read_text().strip()

    def get_num_disks(self):
        return int((self.sysfs / "raid_disks").read_text().strip())

    def get_disks(self):
        for d in range(self.get_num_disks()):
            disk = (self.sysfs / f"rd{d}" / "block").readlink().name
            yield f"/dev/{disk}"

    def write_test(self, offset_sector, bb, sz=1 << 20):
        offset = offset_sector << 9
        self.kmsg.write(f"TEST {offset:#x} {offset_sector} {sz >> 9} {repr(bb)}\n")
        self.kmsg.flush()

        os.lseek(self.fd, offset, os.SEEK_SET)
        m1 = mmap.mmap(-1, sz)
        m1.write(bb * sz)
        os.write(self.fd, m1)

        if self.verify_fd:
            os.lseek(self.verify_fd, offset, os.SEEK_SET)
            os.write(self.verify_fd, m1)

        m2 = mmap.mmap(-1, sz)
        os.lseek(self.fd, offset, os.SEEK_SET)
        self.f.readinto(m2)

        m1.seek(0)
        m2.seek(0)
        a = m1.read()
        b = m2.read()
        print(f"Wrote {len(a)} {repr(bb)}s and read back {len(b)} at {offset:#x} {offset_sector}")
        if a == b:
            return

        coupled_idx = enumerate(zip(a, b))
        res = next(idx for idx, (x, y) in coupled_idx if x != y)

        pathlib.Path("failed.dat").write_bytes(b)
        sys.exit(f"FAILED Readback at sector {offset + res:#x}")

    def basic_tests(self):
        self.write_test(0, b"X")
        self.write_test(1544, b"Y")
        self.write_test(1552, b"Z")
        self.write_test(1560, b"A")
        self.write_test(1736, b"B")
        self.write_test(1688, b"B")
        self.write_test(1848, b"C")
        self.write_test(1520, b"D")
        print()

    def run_random(self, cnt, st=0):
        for i in range(1, cnt+1):
            sector = random.randrange(0, 10000)
            sz = random.randrange(512, 1 << 20, 512)
            self.write_test(sector, bytes([(st + i) & 0xFF]), sz)
        print()

    def verify(self):
        try:
            print("Verifying")
            subprocess.check_call(["cmp", "-b", "-n", "10M",
                                   self.md_dev, "/dev/ram7"])
        except subprocess.SubprocessError:
            sys.exit(1)

    def log(self, msg):
        print(msg)
        self.kmsg.write(msg)
        self.kmsg.flush()

    def wait(self):
        subprocess.call(["mdadm", "--wait", self.md_dev])

    def grow(self, cnt, dev):
        self.wait()
        subprocess.check_call(["mdadm", "--add", self.md_dev, "--quiet", dev])
        subprocess.check_call(["mdadm", "--grow", "--raid-devices", str(cnt),
                               self.md_dev])
        self.log(f"Array grew to {cnt} devices")

    def grow_tests(self, cnt, quick=False):
        if self.get_level() != "raid6":
            self.grow(4, "/dev/ram3")
            self.run_random(cnt, 0x30)

        if quick:
            return

        self.grow(5, "/dev/ram4")
        self.run_random(cnt)
        self.grow(6, "/dev/ram5")
        self.run_random(cnt)

    def degrade(self, dev):
        self.wait()
        subprocess.check_call(["mdadm", "--manage", self.md_dev, "--quiet",
                               "--fail", dev])
        subprocess.check_call(["mdadm", "--manage", self.md_dev, "--quiet",
                               "--remove", dev])
        self.log(f"Marked {dev} failed")

    def recover(self, dev):
        subprocess.check_call(["mdadm", "--manage", "/dev/md0", "--quiet",
                               "--add-spare", dev])
        self.log(f"Restored {dev}")

    def degrade_test(self, cnt, quick=False):
        for d in self.get_disks():
            self.degrade(d)
            self.run_random(cnt // 2)
            self.recover(d)
            self.run_random(cnt // 2)
            if quick:
                return

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    group = parser.add_mutually_exclusive_group()
    group.add_argument("-g", "--grow-test", action="store_true")
    group.add_argument("-d", "--degrade-test", action="store_true")
    parser.add_argument("-q", "--quick", action="store_true")
    parser.add_argument("-V", "--verify", action="store_true",
                        help="verify the disk matches expected when done; " +
                        "NOTE: the upstream kernel has bugs here and it "+
                        "fails randomly")
    args = parser.parse_args()

    runner = TestRunner(args.verify)
    runner.basic_tests()

    cnt = 400
    if args.quick:
        cnt = 6

    runner.run_random(cnt)

    if args.grow_test:
        runner.grow_tests(cnt, args.quick)
    elif args.degrade_test:
        runner.degrade_test(cnt, args.quick)

    if args.verify:
        runner.verify()
